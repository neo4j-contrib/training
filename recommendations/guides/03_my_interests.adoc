= Recommendations by explicit interest
include::include.adoc[]

== Member Interests (Topics)

In the previous section we finished by looking at groups similar to the ones that people were already members of.
In this section we'll take that a step further by looking at members explicit interests as well as inferring them if they aren't specified.

image::{img}/slides.jpg[]

== Member Interests (Topics)

image::{img}/group_has_topic_member_of_interested_in.png[]

What data do we have?
Run the following query to find out:

[source,cypher,subs=attributes]
----
LOAD CSV WITH HEADERS
FROM "{csv-url}members.csv" AS row
RETURN row.id, row.topics
LIMIT 10
----

Note that we're still processing the same members file as we were earlier but returning different columns this time.

So we've got one column containing the member id and one with a `;` delimited set of topic ids.
Our next task is to create a relationship between members and their topics.
To do that we're going to need to split up the string containing topic ids so we can process them one at a time.

We'll use link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#functions-split[split()] and link:http://neo4j.com/docs/new-manual/developer-manual/3.0-RC1/#query-plan-unwind[UNWIND] to help us do this.

ifdef::env-training[]

== The slides are waiting...for you!

image::{img}/slides.jpg[]

endif::env-training[]

== Member Interests (Topics)

Run the following query to create an `INTERESTED_IN` relationship between members and topics:

[source,cypher,subs=attributes]
----
USING PERIODIC COMMIT 50000
LOAD CSV WITH HEADERS FROM "{csv-url}members.csv" AS row

WITH split(row.topics, ";") AS topics, row.id AS memberId
UNWIND topics AS topicId

WITH DISTINCT memberId, topicId
MATCH (member:Member {id: memberId})
MATCH (topic:Topic {id: topicId})
MERGE (member)-[:INTERESTED_IN]->(topic)
----

This might take a bit of time - there's a lot of members and topics to get through!

== Find my similar groups

Now we're ready to write our first query which uses some data we've explicitly provided to meetup.com.

include::form.adoc[tags=name]

[source,cypher,subs="attributes,none"]
----
MATCH (member:Member {name: {name}})-[:INTERESTED_IN]->(topic),
      (member)-[:MEMBER_OF]->(group)-[:HAS_TOPIC]->(topic)
WITH member, topic, COUNT(*) AS score
MATCH (topic)<-[:HAS_TOPIC]-(otherGroup)
WHERE NOT (member)-[:MEMBER_OF]->(otherGroup)
RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score
ORDER BY score DESC
LIMIT 10
----

In this query we

  * start from a user
  * find the topics they are interested in
  * find the groups they are a member of that have those (relevant) topics
  * aggregates the number of times each topic appears
  * finds other groups that have these topics, filtering out ones that the user is already a member of
  * returns those other groups sorted by how many of the member's topics they cater for

This is quite a crude scoring mechanism which favours generally popular topics.
We'll have a look at how to address that later on.

== Next Step

We're now reached the end of the group recommendation section of the training.
In the next section we're going to explore the events hosted by our groups and then make event recommendations.

// pass:a[<a play-topic='{guides}/04_events.html'>Event Recommendations</a>]
